# Analysis
To attack our system, we attached a debugger to a running process and manipulated variables that were in memory. In this way, you can pretty much make your character whatever you want it to be, including giving yourself more HP than is possible to achieve in game, etc.  As we pointed out in our design doc, there isn't really a good way to do protect in memory variables when the system the game is running on isn't controlled by you.  Some ways to mitigate this risk are to only ever release a stripped binary and not the source code, making it quite a bit tougher to figure out what variables do what without some serious effort.  To completely fix this, we'd have to never store a "truth" about any character on the client, and the character itself would never live on the client, only in the server.  We'd then just send commands to the server, and the server (controlled by us) would do the calculations.

We also did a network analysis, running wireshark while we talked back and forth with the server.  This turned out to be somewhat comforting, as the only data we could retreive without having a user's password, was the name of the character they were logged in to and the initialization vector used to encrypt the character data.  We knew that would be the case already, and we didn't consider the character name being accessible to be a huge deal. That being said, if we really wanted to lock that down, we could have hashed the username before we sent it to the server. The IV however, would still need to be in plain text, but again that is just fine as long as we are making sure to use a different IV each time we encrypt data (which we are doing using the OpenSSL rand library).

We also made some incremental changes to our program, trying to prevent buffer overflows by switching all instances of `gets` to `fgets`, which does a pretty good job of limiting buffer overflow attacks.  There are likely some places where a memcpy could go south and force a coredump, but we haven't been able to reproduce any as of yet.